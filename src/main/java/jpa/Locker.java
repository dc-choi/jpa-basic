package jpa;

import lombok.Getter;
import lombok.Setter;

import javax.persistence.*;

/**
 * 일대일
 *
 * 주 테이블이나 대상 테이블중에 외래키 선택 가능
 * 외래키에 데이터베이스 유니크 제약조건 추가
 *
 * 외래키가 있는 곳이 연관관계의 주인이다.
 * 반대편은 mappedBy를 적용시킨다.
 *
 * 일대일 관계에서는 단뱡항은 지원하지않고 양방향만 지원한다.
 *
 * 주 테이블에 외래키를 넣을 경우
 * 1. 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래키를 두고 대상 테이블을 찾음.
 * 2. 객체지향 개발자가 선호하는 방식이고 JPA 매핑이 편리하다.
 * 3. 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
 * 4. 값이 없으면 외래키에 null이 허용된다.
 *
 * 대상 테이블에 외래키를 넣을 경우
 * 1. 대상 테이블에 외래키가 존재하는 방식으로 전통적인 데이터베이스의 매핑 방식이다.
 * 2. 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조를 유지한다.
 * 3. 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨.
 * (주 테이블에서 검색하는 경우 대상 테이블에 데이터가 있는지 확인을 해야하기 때문에)
 *
 * 참고: 주 테이블과 대상 테이블을 나누는 기준은 비즈니스 관점에서 조회를 더 많이 하느냐 안하느냐의 차이다.
 * 보통 게시판, 첨부파일이라고 한다면 게시판이 주 테이블이 될 가능성이 높다.
 */
@Entity
@Table(name = "locker")
@Getter
@Setter
public class Locker {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToOne(mappedBy = "locker")
    private Developer developer;
}
/**
 * 다대다
 *
 * RDB 패러다임에서는 다대다를 중간 테이블을 두고 풀어냄
 * 하지만 객체의 관점에서는 컬렉션을 사용해서 객체 2개로 다대다 관계를 맺는 것이 가능하다.
 *
 * @ManyToMany 어노테이션을 사용하고 @JoinTable로 연결 테이블을 지정할 수 있다. 단방향과 양방향 둘다 가능하다.
 *
 * 편리해보이지만 실무에서 사용하지 않는다... 연결 테이블이 단순하게 연결만 하고 끝나지 않는다.
 * 주문 시간, 수량 같은 데이터가 들어올 수 있다. 다대다를 사용하면 추가 컬럼을 사용할 수 없다.
 * 그리고 연결 테이블이 보이지 않기 때문에 예상할 수 없는 쿼리가 나가기도 한다.
 *
 * 그래서 연결 테이블에 대한 엔티티를 추가하고 다대다를 일대다 다대일로 풀어낸다.
 */
